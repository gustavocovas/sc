<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Perlin Noise</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <style>
      canvas {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <canvas id="perlin" width="500" height="500"></canvas>

    <script>
      const WORLD_WIDTH = 50;
      const WORLD_HEIGHT = 50;
      const CELL_SIZE = 10;
      const PERLIN_GRID_SCALE = 5;

      let world = [];
      let perlin_grid = [];

      let canvas = document.querySelector("#perlin");
      let context = canvas.getContext("2d");

      start();

      function start() {
        init_world();
        update();
      }

      function init_world() {
        for (var i = 0; i < WORLD_HEIGHT; i++) {
          world[i] = [];
        }

        for (var i = 0; i < WORLD_HEIGHT; i++) {
          for (var j = 0; j < WORLD_WIDTH; j++) {
            world[i][j] = { x: j * CELL_SIZE, y: i * CELL_SIZE, type: "land" };
          }
        }

        let perlin_grid_height =
          Math.floor(WORLD_HEIGHT / PERLIN_GRID_SCALE) + 1;
        let perlin_grid_width = Math.floor(WORLD_WIDTH / PERLIN_GRID_SCALE) + 1;

        for (var i = 0; i < perlin_grid_height; i++) {
          perlin_grid[i] = [];
        }

        for (var i = 0; i < perlin_grid_height; i++) {
          for (var j = 0; j < perlin_grid_width; j++) {
            let r = 2 * Math.PI * Math.random();
            let gradient = { x: Math.cos(r), y: Math.sin(r) };

            perlin_grid[i][j] = {
              i: i * PERLIN_GRID_SCALE,
              j: j * PERLIN_GRID_SCALE,
              gradient: gradient,
            };
          }
        }

        console.log(world);
        console.log(perlin_grid);
      }

      // Perlin noise for cell at world[i][j]
      function perlin(i, j) {
        let pi0 = Math.floor(i / PERLIN_GRID_SCALE);
        let pi1 = pi0 + 1;
        let pj0 = Math.floor(j / PERLIN_GRID_SCALE);
        let pj1 = pj0 + 1;

        console.log(
          "i",
          i,
          "j",
          j,
          "pi0",
          pi0,
          "pi1",
          pi1,
          "pj0",
          pj0,
          "pj1",
          pj1
        );

        let g00 = perlin_grid[pi0][pj0];
        let g01 = perlin_grid[pi0][pj1];
        let g10 = perlin_grid[pi1][pj0];
        let g11 = perlin_grid[pi1][pj1];

        // Determine interpolation weights
        let sj = (j + 0.5 - g00.j) / PERLIN_GRID_SCALE;
        let si = (i + 0.5 - g00.i) / PERLIN_GRID_SCALE;
        console.log("interpolation weights", sj, si);

        // Interpolate between grid point gradients
        let n0 = dotGridGradient(g00, i, j);
        let n1 = dotGridGradient(g01, i, j);
        let ix0 = interpolate(n0, n1, sj);

        console.log("n0 n1 ix0", n0, n1, ix0);

        n0 = dotGridGradient(g10, i, j);
        n1 = dotGridGradient(g11, i, j);
        let ix1 = interpolate(n0, n1, sj);

        return interpolate(ix0, ix1, si);
      }

      // Computes the dot product of the distance and gradient vectors.
      function dotGridGradient(cell, i, j) {
        // Compute the distance vector
        let dj = (j + 0.5 - cell.j) / PERLIN_GRID_SCALE;
        let di = (i + 0.5 - cell.i) / PERLIN_GRID_SCALE;

        console.log("dist", dj, di);

        // Compute the dot-product
        return dj * cell.gradient.x + di * cell.gradient.y;
      }

      function interpolate(a0, a1, w) {
        return (a1 - a0) * w + a0;
      }

      function update() {
        context.clearRect(0, 0, canvas.width, canvas.height);

        for (var i = 0; i < WORLD_HEIGHT; i++) {
          for (var j = 0; j < WORLD_WIDTH; j++) {
            const cell = world[i][j];

            context.beginPath();
            context.rect(cell.x, cell.y, CELL_SIZE, CELL_SIZE);

            let alpha = (1 + perlin(i, j)) / 2;
            console.log("alpha", alpha);

            // if (alpha > 0.55) {
            //   context.fillStyle = "white";
            // } else {
            //   context.fillStyle = "black";
            // }

            context.fillStyle = "rgba(0, 0, 0, " + alpha + ")";
            context.fill();
          }
        }

        // requestAnimationFrame(update);
      }
    </script>
  </body>
</html>
